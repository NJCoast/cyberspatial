# Notes on Google Cloud Platform and Kubernetes

The base configuration for Kubernetes is generated by the [kompose](http://kompose.io/) tool from the default docker-compose.yml file (which is the deployment, not development configuration).

Secrets for deployment should be stored in a seperate yml that is NOT commited to github.

A good description of Google Cloud, Kubernetes and Django deployment can be found in this google cloudb [blog](https://medium.com/google-cloud/deploying-django-postgres-redis-containers-to-kubernetes-9ee28e7a146) and [part 2](https://medium.com/google-cloud/deploying-django-postgres-and-redis-containers-to-kubernetes-part-2-b287f7970a33).

## Setup of Google Cloud using the command line sdk
The google cloud sdk in available in brew casks.
```bash
$ brew cask install google cloud sdk
```

Which will set up the command line tool. The gcloud command line tool needs to be linked to a google cloud project for billing.
```bash
gcloud components update # make sure it’s up to date
gcloud config set project <project-id>
# Create the cluster with 2 nodes
gcloud container clusters create njcoast --scopes "https://www.googleapis.com/auth/userinfo.email","cloud-platform" --num-nodes 2
# Configure kubectl with the right context
gcloud container clusters get-credentials njcoast
```

Which creates a cluster with two nodes. Note that there have been reports of performance issues for less than three nodes.

Here we are creating 2 nodes. Note that for Container Engine, you will be billed for the instances you are creating (but for up to 5 nodes, there are no additional charges).
When you’re done with this tutorial, to avoid recurring charges, delete the instances.

To shut down the cluster instances, and avoid additional charges.
```bash
gcloud container clusters delete njcoast
```

After the cluster is spun up, you should have assess to the Kubernetes deployment using kubectl. The main CLI to interact with the Kubernetes cluster will be kubectl. At first, the only existing Service should be Kubernetes, and you shouldn’t have any pods.
````bash
$ kubectl get services
$ kubectl get pods
```


## Kubernetes on local mac environment
I turned off docker for mac to be safe. In principle, docker will try socket file first, the env, so both should be able to coexist.

Get docker machine going with xhyve (built in mac) virtualization.
```bash
docker-machine create --driver xhyve xhyve-test
docker-machine env xhyve-test
eval $(docker-machine env xhyve-test)
```

Start minicube with docker environment and the xhyve driver (otherwise it trys to grab virtualbox base box instead).
```bash
minikube start --docker-env eval $(docker-machine env xhyve-test) --vm-driver=xhyve
```

Run sample project. Kubectl should work as normal after this using env variables.
```bash
kubectl run hello-minikube --image=gcr.io/google_containers/echoserver:1.4 --port=8080
```

## Build geonode django container.

Docker-compose handles building of the frontend containers. But to push to kubernetes or to google clouds private repository, we need to build the container with specific tags. From the root directory.

```bash
$ docker build -t njcoast/cyberspatial ./docker_compose/django/production/
```

Once you’ve replaced the image attribute with the Docker image you pushed, let’s create the Service and Replication Controller:
```bash
$ kubectl create -f kubernetes_configs/frontend.yaml
```


And you can check the status with:

```bash
$ kubectl get services
NAME CLUSTER_IP EXTERNAL_IP PORT(S) SELECTOR AGE
frontend 10.67.240.157 104.197.69.33 80/TCP name=frontend
kubernetes 10.67.240.1 <none> 443/TCP <none>
```


## Kubernetes debugging tips.

From Bill Prin's medium article.
The command kubectl logs will show the standard output/error of the container, which is usually the first place to look for problems.

```bash
$ kubectl logs <pod name>
```

You can exec a shell with kubectl using:
```bash
$ kubectl exec <frontend-pod> -- cat /etc/secrets/djangouserpw
```

If you want to see all of the Kubernetes meta-information about a resource, try `kubectl describe`:

```bash
$ kubectl describe pod <pod_name>
$ kubectl describe service <service_name>
$ kubectl describe rc <rc_name>
```

When you run into problems, it sometime helps to rebuild the resource:

```bash
$ kubectl delete rc frontend
$ kubectl create -f kubernetes_configs/frontend.yaml
```

##
